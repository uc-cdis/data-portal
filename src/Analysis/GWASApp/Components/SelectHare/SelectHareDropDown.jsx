import React from 'react';
import PropTypes from 'prop-types';
import { useQueries } from 'react-query';
import { Spin, Select } from 'antd';
import { fetchConceptStatsByHareSubset } from '../../Utils/cohortMiddlewareApi';
import queryConfig from '../../../SharedUtils/QueryConfig';
import { useSourceContext } from '../../Utils/Source';
import ACTIONS from '../../Utils/StateManagement/Actions';

const SelectHareDropDown = ({
  id,
  selectedCohort,
  covariates,
  outcome,
  dispatch,
}) => {
  const { source } = useSourceContext();
  const hareResults = useQueries(
    outcome.variable_type === 'concept'
      ? [
        {
          queryKey: [
            'conceptstatsbyhare',
            outcome,
            covariates,
            selectedCohort,
          ],
          queryFn: () => fetchConceptStatsByHareSubset(
            selectedCohort.cohort_definition_id,
            covariates,
            outcome,
            source,
          ),
          ...queryConfig,
        },
      ]
      : [
        {
          queryKey: [
            'conceptstatsbyharecontrol',
            outcome,
            covariates,
            selectedCohort,
          ],
          queryFn: () => fetchConceptStatsByHareSubset(
            selectedCohort.cohort_definition_id,
            [
              ...covariates,
              {
                variable_type: 'custom_dichotomous',
                cohort_ids: [
                  selectedCohort.cohort_definition_id,
                  outcome.cohort_ids[1],
                ],
                provided_name:
                      'Autogenerated variable for filtering out Case Population',
              },
            ],
            outcome,
            source,
          ),
          ...queryConfig,
        },
        {
          queryKey: [
            'conceptstatsbyharecase',
            outcome,
            covariates,
            selectedCohort,
          ],
          queryFn: () => fetchConceptStatsByHareSubset(
            selectedCohort.cohort_definition_id,
            [
              ...covariates,
              {
                variable_type: 'custom_dichotomous',
                cohort_ids: [
                  selectedCohort.cohort_definition_id,
                  outcome.cohort_ids[0],
                ],
                provided_name:
                      'Autogenerated variable for filtering out Control Population',
              },
            ],
            outcome,
            source,
          ),
          ...queryConfig,
        },
      ],
  );

  const determineDichotomousSizes = (selectedHareItem) => {
    let finalControlCohortSize;
    if (hareResults[0].data.concept_breakdown !== null) {
      finalControlCohortSize = hareResults[0].data.concept_breakdown.find(
        (hare) => selectedHareItem.value === hare.concept_value,
      ).persons_in_cohort_with_value;
    } else {
      finalControlCohortSize = 0;
    }

    let finalCaseCohortSize;
    if (hareResults[1].data.concept_breakdown !== null) {
      finalCaseCohortSize = hareResults[1].data.concept_breakdown.find(
        (hare) => selectedHareItem.value === hare.concept_value,
      ).persons_in_cohort_with_value;
    } else {
      finalCaseCohortSize = 0;
    }
    return { finalControlCohortSize, finalCaseCohortSize };
  };

  const getFinalPopulationSizes = (selectedHareItem) => {
    if (outcome.variable_type === 'concept') {
      // Quantitative outcome scenario:
      const finalCohortSize = hareResults[0].data.concept_breakdown.find(
        (hare) => selectedHareItem.value === hare.concept_value,
      ).persons_in_cohort_with_value;
      return [{ population: 'Total', size: finalCohortSize }];
    }
    // Dichotomous (aka Case/Control) outcome scenario:
    const {
      finalControlCohortSize,
      finalCaseCohortSize,
    } = determineDichotomousSizes(selectedHareItem);
    return [
      { population: 'Control', size: finalControlCohortSize },
      { population: 'Case', size: finalCaseCohortSize },
      {
        population: 'Total',
        size: finalControlCohortSize + finalCaseCohortSize,
      },
    ];
  };

  const getConceptId = (selectedHareItem) => hareResults[0].data.concept_breakdown.find(
    (hare) => selectedHareItem.value === hare.concept_value,
  ).concept_value_as_concept_id;

  const onChange = (h) => {
    const selectedHareOutput = {
      concept_value: h.value,
      concept_value_as_concept_id: getConceptId(h),
      concept_value_name: h.label,
    };
    dispatch({
      type: ACTIONS.UPDATE_SELECTED_HARE,
      payload: selectedHareOutput,
    });
    dispatch({
      type: ACTIONS.UPDATE_FINAL_POPULATION_SIZES,
      payload: getFinalPopulationSizes(h),
    });
  };

  if (hareResults.some((hareResult) => hareResult.status === 'loading')) {
    return <Spin />;
  }
  if (hareResults.some((hareResult) => hareResult.status === 'error')) {
    return <React.Fragment>error</React.Fragment>;
  }
  return (
    <Select
      id={id}
      showSearch
      labelInValue
      onChange={onChange}
      placeholder='-select one of the ancestry groups below-'
      fieldNames={{ label: 'concept_value_name', value: 'concept_value' }}
      options={hareResults[0].data?.concept_breakdown} // even when hareResults.length === 2, we can use hareResults[0] as the concept_breakdown descriptions should be the same
      dropdownStyle={{ width: '800' }}
      filterOption={(searchTerm, option) => (option?.concept_value_name ?? '')
        .toLowerCase()
        .includes(searchTerm.toLowerCase())}
    />
  );
};

SelectHareDropDown.propTypes = {
  id: PropTypes.string.isRequired,
  selectedCohort: PropTypes.object.isRequired,
  outcome: PropTypes.object.isRequired,
  covariates: PropTypes.array.isRequired,
  dispatch: PropTypes.func.isRequired,
};

export default SelectHareDropDown;
